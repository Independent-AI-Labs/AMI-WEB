#!/usr/bin/env bash
# Native git pre-commit hook - replaces pre-commit framework
# Runs all quality checks serially without auto-stashing unstaged changes

set -euo pipefail

# Standardized terminology: MODULE_ROOT and ORCHESTRATOR_ROOT only
MODULE_ROOT="$(git rev-parse --show-toplevel)"
GIT_DIR="$(git rev-parse --git-dir)"

# Check if this is orchestrator root or a submodule
if [ -f "$MODULE_ROOT/.git" ]; then
    # Submodule - .git is a file pointing to parent
    MODULE_NAME="$(basename "$MODULE_ROOT")"
    IS_ROOT=false
    ORCHESTRATOR_ROOT="$(cd "$MODULE_ROOT/.." && pwd)"
else
    # Orchestrator root
    MODULE_NAME="root"
    IS_ROOT=true
    ORCHESTRATOR_ROOT="$MODULE_ROOT"
fi

echo "Running pre-commit checks for ${MODULE_NAME}..."
echo "=========================================="

# CRITICAL: Check for unstaged changes FIRST
if [ "$IS_ROOT" = true ]; then
    # Root: check for dirty submodules
    if [ -d ".git/modules" ] && git submodule status | grep -q "^\+"; then
        echo "✗ BLOCKED: Dirty submodules detected. Commit inside submodules first!"
        exit 1
    fi
fi

# Check for unstaged changes
if ! git diff --quiet; then
    echo "✗ BLOCKED: Unstaged changes detected. Run 'git add -A' before commit."
    echo ""
    echo "Unstaged files:"
    git diff --name-only
    exit 1
fi

echo "✓ No unstaged changes"

# Set module argument for quality scripts
if [ "$IS_ROOT" = true ]; then
    MODULE_ARG="root"
else
    MODULE_ARG="$MODULE_NAME"
fi

# 1. Ruff format
echo ""
echo "Running ruff format..."
RUFF_BIN="${MODULE_ROOT}/.venv/bin/ruff"
RUFF_CONFIG="${ORCHESTRATOR_ROOT}/base/scripts/ruff.toml"
RUFF_TARGET="."

if ! "$RUFF_BIN" format --config "$RUFF_CONFIG" "$RUFF_TARGET"; then
    echo "✗ ruff format failed"
    exit 1
fi
echo "✓ ruff format passed"

# 3. Ruff lint
echo ""
echo "Running ruff lint..."
if ! "$RUFF_BIN" check --config "$RUFF_CONFIG" --fix --exit-non-zero-on-fix "$RUFF_TARGET"; then
    echo "✗ ruff lint failed"
    exit 1
fi
echo "✓ ruff lint passed"

# 4. Stage ruff's automatic fixes
echo ""
echo "Staging ruff fixes..."
git add -A
echo "✓ Ruff fixes staged"

# 5. Banned words
echo ""
echo "Running banned-words..."
if ! "${MODULE_ROOT}/.venv/bin/python" "${ORCHESTRATOR_ROOT}/base/scripts/quality/banned_words.py" "$MODULE_ARG"; then
    echo "✗ banned-words failed"
    exit 1
fi
echo "✓ banned-words passed"

# 6. No lint suppressions
echo ""
echo "Running no-lint-suppressions..."
if ! "${MODULE_ROOT}/.venv/bin/python" "${ORCHESTRATOR_ROOT}/base/scripts/quality/code_check.py" "$MODULE_ARG"; then
    echo "✗ no-lint-suppressions failed"
    exit 1
fi
echo "✓ no-lint-suppressions passed"

# 7. Mypy
echo ""
echo "Running mypy..."
MYPY_BIN="${MODULE_ROOT}/.venv/bin/python"
MYPY_CONFIG="${ORCHESTRATOR_ROOT}/base/scripts/mypy.ini"

if [ "$IS_ROOT" = true ]; then
    # Root: check from orchestrator directory
    MYPY_WORKDIR="$MODULE_ROOT"
    MYPY_TARGETS="backend scripts"
else
    # Submodules: check from parent using package name to avoid duplicate detection
    MYPY_WORKDIR="$ORCHESTRATOR_ROOT"
    MYPY_TARGETS="-p $MODULE_NAME"
fi

if ! (cd "$MYPY_WORKDIR" && "$MYPY_BIN" -m mypy $MYPY_TARGETS --config-file="$MYPY_CONFIG"); then
    echo "✗ mypy failed"
    exit 1
fi
echo "✓ mypy passed"

# 8. Check YAML files
echo ""
echo "Checking YAML files..."
YAML_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(ya?ml)$' || true)
if [ -n "$YAML_FILES" ]; then
    for file in $YAML_FILES; do
        if ! python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null; then
            echo "✗ Invalid YAML: $file"
            exit 1
        fi
    done
    echo "✓ YAML files valid"
else
    echo "✓ No YAML files to check"
fi

# 9. Check for large files (>100MB)
echo ""
echo "Checking for large files..."
LARGE_FILES=$(git diff --cached --name-only --diff-filter=ACM | while read file; do
    if [ -f "$file" ]; then
        SIZE=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
        if [ "$SIZE" -gt 104857600 ]; then
            echo "$file"
        fi
    fi
done)

if [ -n "$LARGE_FILES" ]; then
    echo "✗ Large files detected (>100MB):"
    echo "$LARGE_FILES"
    exit 1
fi
echo "✓ No large files"

# 10. Check for merge conflicts
echo ""
echo "Checking for merge conflict markers..."
CONFLICT_FILES=$(git diff --cached --name-only --diff-filter=ACM | while read file; do
    if [ -f "$file" ] && grep -qE '^(<<<<<<<|=======|>>>>>>>)' "$file"; then
        echo "$file"
    fi
done)

if [ -n "$CONFLICT_FILES" ]; then
    echo "✗ Merge conflict markers found:"
    echo "$CONFLICT_FILES"
    exit 1
fi
echo "✓ No merge conflicts"

# 11. Check for debug statements (Python only)
echo ""
echo "Checking for debug statements..."
PY_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$' || true)
if [ -n "$PY_FILES" ]; then
    DEBUG_FILES=$(echo "$PY_FILES" | while read file; do
        if [ -f "$file" ] && grep -nE '(^|[^a-zA-Z0-9_])(pdb|ipdb|pudb|debugpy|breakpoint)\.(set_trace|runcall)\(' "$file"; then
            echo "$file"
        fi
    done)

    if [ -n "$DEBUG_FILES" ]; then
        echo "✗ Debug statements found:"
        echo "$DEBUG_FILES"
        exit 1
    fi
    echo "✓ No debug statements"
else
    echo "✓ No Python files to check"
fi

echo ""
echo "=========================================="
echo "✓ All pre-commit checks passed!"
exit 0
